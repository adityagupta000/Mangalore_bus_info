function e(e,t){if(!1===e||null==e)throw console.warn("Test invariant failed:",t),new Error(t)}class t{nodes=new Set;edges=new Map;edgeWeights=new Map;edgeProperties=new Map;addNode(e){return this.nodes.has(e)||this.nodes.add(e),this.edges.has(e)||this.edges.set(e,new Set),this}removeNode(e){this.edges.delete(e),this.nodes.delete(e);for(const t of this.edges.values())t.delete(e);return this}adjacent(e){return this.edges.get(e)}setEdgeWeight(t,o,r){this.edgeWeights.has(t)||this.edgeWeights.set(t,new Map);const n=this.edgeWeights.get(t);return e(n),n.set(o,r),this}getEdgeWeight(e,t){return this.edgeWeights.get(e)?.get(t)??1}setEdgeProperties(t,o,r){this.edgeProperties.has(t)||this.edgeProperties.set(t,new Map);const n=this.edgeProperties.get(t);return e(n),n.set(o,r),this}getEdgeProperties(e,t){return this.edgeProperties.get(e)?.get(t)}addEdge(t,o,...r){let n,s;const d=r[0];"number"==typeof d&&(n=d),"object"==typeof d&&(n=d.weight,d&&(s=Object.prototype.hasOwnProperty.call(d,"props")?d.props:void 0)),this.addNode(t),this.addNode(o);const i=this.adjacent(t);return e(i),i.add(o),void 0!==n&&this.setEdgeWeight(t,o,n),void 0!==s&&this.setEdgeProperties(t,o,s),this}removeEdge(e,t){return this.edges.get(e)?.delete(t),this.edgeProperties.get(e)?.delete(t),this}hasEdge(e,t){return this.edges.get(e)?.has(t)??!1}}class o extends Error{constructor(e){super(e),Object.setPrototypeOf(this,o.prototype)}}function r(e,t,n,s,d,i){const{errorOnCycle:g=!1,shouldFollow:h}=i;if(s.has(d)&&g)throw new o("Cycle found");n.has(d)||(n.add(d),s.add(d),e.adjacent(d)?.forEach((o=>{(void 0===h||h({source:d,target:o,graph:e,props:e.getEdgeProperties(d,o)}))&&r(e,t,n,s,o,i)})),s.delete(d),t.push(d))}function n(e,t={}){const{sourceNodes:o=Array.from(e.nodes),includeSourceNodes:n=!0}=t,s=new Set,d=new Set,i=[];if(n){for(let n=0;n<o.length;n++){const g=o[n];g&&r(e,i,s,d,g,t)}return i}for(let e=0;e<o.length;e++){const t=o[e];t&&s.add(t)}for(let n=0;n<o.length;n++){const g=o[n];g&&e.adjacent(g)?.forEach((o=>r(e,i,s,d,o,t)))}return i}function s(e){let t,o=1/0;const{d:r,q:n}=e;return n.forEach((e=>{const n=r.get(e)??1/0;n<o&&(o=n,t=e)})),void 0===t?(n.clear(),null):(n.delete(t),t)}function d(t,o,r,n){const{d:s,p:d}=o,i=t.getEdgeWeight(r,n),g=s.get(r),h=s.get(n);e(g,"Missing source distance"),e(h,"Missing target distance"),h>g+i&&(s.set(n,g+i),d.set(n,r))}function i(e,t,o,r){const n=e.nodes,{q:i}=t;for(!function(e,{d:t},o,r){if(e.forEach((e=>{t.set(e,1/0)})),t.get(o)!==1/0)throw new Error("Source node is not in the graph");if(t.get(r)!==1/0)throw new Error("Destination node is not in the graph");t.set(o,0)}(n,t,o,r),function(e,{q:t}){e.forEach((e=>{t.add(e)}))}(n,t);0!==i.size;){const o=s(t);if(null===o)return;e.adjacent(o)?.forEach((r=>{d(e,t,o,r)}))}}function g(e,t,o){const r={d:new Map,p:new Map,q:new Set};return i(e,r,t,o),function(e,t,o,r){const{p:n}=t,s=[];let d=0,i=r;for(;n.has(i);){const t=n.get(i);s.push(i),d+=e.getEdgeWeight(t,i),i=t}if(i!==o)throw new Error("No path found");return s.push(i),s.reverse(),{nodes:s,weight:d}}(e,r,t,o)}function h(e,t,o){let r=g(e,t,o);const n=[r],s=r.weight,d=[];for(;r.weight;){const i=r.nodes[0],h=r.nodes[1];e.hasEdge(i,h)&&(d.push({u:i,v:h,weight:e.getEdgeWeight(i,h),props:e.getEdgeProperties(i,h)}),e.removeEdge(i,h)),e.hasEdge(h,i)&&(d.push({u:h,v:i,weight:e.getEdgeWeight(h,i),props:e.getEdgeProperties(h,i)}),e.removeEdge(h,i));try{if(r=g(e,t,o),!r.weight||s<r.weight)break;n.push(r)}catch(e){break}}for(const{u:t,v:o,weight:r,props:n}of d)e.addEdge(t,o,r,n);return n}function c(e,t={}){return n(e,{...t,errorOnCycle:!0}).reverse()}function a(e,t,o){const r=[],n=[];return u(e,r,n,new Set,t,o)&&f(e,r,n,new Set,o),n}function u(e,t,o,r,n,s){return!!r.has(n)||(r.add(n),t.push(n),n==s?(o.push(n),!1):Array.from(e.adjacent(n)??[]).every((n=>u(e,t,o,r,n,s))))}function f(e,t,o,r,n){r.has(n)||(r.add(n),t.indexOf(n)>=0?o.push(n):0==o.length&&e.adjacent(n)?.forEach((n=>{f(e,t,o,r,n)})))}function p(e,t){let o=0;for(const r of e.edges.values())for(let e of r)e===t&&o++;return o}function l(e,t){return e.edges.get(t)?.size??0}function w(e){const o=new t;for(let[t,r]of e.edges.entries())r.forEach((r=>{o.addEdge.apply(o,[t,r]);const n=e.edgeWeights.get(t)?.get(r);n&&o.setEdgeWeight(t,r,n);const s=e.getEdgeProperties(t,r);s&&o.setEdgeProperties(t,r,s)}));return o}function E(e,t){try{return n(e,{...t,includeSourceNodes:!0,errorOnCycle:!0}),!1}catch(e){if(e instanceof o)return!0;throw e}}function y(e,...t){const o="function"==typeof t[0]?t[0]:void 0,r="function"==typeof t[0]?t[1]:t[0],{includeDefaultWeight:n=!1}=r??{},s={nodes:Array.from(e.nodes),links:[]},d=new Map;return s.nodes.forEach((t=>{const r=t;e.adjacent(r)?.forEach((t=>{const i=e.getEdgeWeight(r,t),g=e.getEdgeProperties(r,t);o&&!d.has(r)&&d.set(r,o(r)),o&&!d.has(t)&&d.set(t,o(t));const h={source:d.get(r)??r,target:d.get(t)??t};(1!=i||n)&&(h.weight=i),g&&(h.props=g),s.links.push(h)}))})),s}function v(...e){const[o,r]=e,n=new t,s=new Map;return o.nodes.forEach((e=>{n.addNode(e),r&&s.set(r(e),e)})),o.links.forEach((e=>{if(!r)return void n.addEdge.apply(n,[e.source,e.target,e.weight,e.props]);const t=s.get(r(e.source))??e.source,o=s.get(r(e.target))??e.target;n.addEdge.apply(n,[t,o,e.weight,e.props])})),n}function P(e,t){const o=[];return e.nodes.forEach((e=>{t(e)&&o.push(e)})),o}function W(e,t){const o=[];for(const r of e.nodes)t(r)&&o.push(r);if(0===o.length)throw new Error("Node not found.");if(o.length>1)throw new Error("More than one node found.");return o[0]}function M(e,t){for(const o of e.nodes)if(t(o))return o;throw new Error("Node not found.")}export{o as CycleError,t as Graph,w as cloneGraph,n as depthFirstSearch,v as deserializeGraph,P as findNodes,M as getFirstNode,W as getNode,E as hasCycle,p as indegree,a as lowestCommonAncestors,l as outdegree,y as serializeGraph,g as shortestPath,h as shortestPaths,c as topologicalSort};
//# sourceMappingURL=index.mjs.map
